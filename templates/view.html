<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Replay: {{note}}</title>
        <link rel="stylesheet" href="/replay/static/css/asciinema-player.css" />
        <link rel="stylesheet" href="/replay/static/css/pico.min.css" />
        <style>
            table.heartbeats {
                border-collapse: collapse;
            }
            table.heartbeats tbody.session + tbody.session {
                border-top: 2px solid #d0d0d0;
            }
            table.heartbeats tbody.session:first-child {
                border-top: none;
            }
            .marks td:last-child,
            .marks th:last-child {
                width: 1%;
                white-space: nowrap;
                padding-left: 0.25rem;
                padding-right: 0.25rem;
                text-align: center;
            }
            .del-btn,
            .add-btn {
                margin-bottom: 0px !important;
            }
            .marks td:first-child span {
                font-family: ui-monospace, SFMono-Regular, Consolas, monospace;
            }
        </style>
        <script src="/replay/static/js/asciinema-player.min.js"></script>
    </head>
    <body style="margin: 2rem 0rem">
        <main class="container">
            <div class="pico">
                <label>
                    Speed:
                    <output id="speedVal">1.0</output>
                    <input
                        id="speed"
                        type="range"
                        min="0.5"
                        max="10"
                        step="0.1"
                        value="1.0"
                        autocomplete="off"
                    />
                </label>
                <label id="idleLabel">
                    Idle Time:
                    <output id="idleVal">inf</output>
                    <input
                        id="idle"
                        type="range"
                        min="2"
                        max="62"
                        step="2"
                        value="62"
                        list="idleTicks"
                        autocomplete="off"
                    />
                </label>
            </div>
            <h2 class="pico">Uploaded At</h2>
            <span class="pico" style="color: #666">{{uploaded_at | human}}</span>
            <h2 class="pico">Notes</h2>
            <div class="pico">
                <pre><code>{{note}}</code></pre>
            </div>

            <h2 class="pico">Heartbeats</h2>
            <table class="heartbeats pico">
                <thead>
                    <tr>
                        <th scope="col">Session</th>
                        <th scope="col">Started At</th>
                        <th scope="col">Ended At</th>
                        <th scope="col">Duration</th>
                    </tr>
                </thead>
                {% for (session, itvs) in heartbeats %}
                <tbody class="session">
                    {% for itv in itvs %}
                    <tr>
                        <td>{{ session }}</td>
                        <td>{{ itv.0 | human }}</td>
                        <td>{{ itv.1 | human }}</td>
                        <td>{{ itv.1 - itv.0 }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
                {% endfor %}
            </table>

            {% for cast in casts %}
            <h2 class="pico">Cast {{loop.index}}</h2>
            <p style="color: #666">{{cast.started_at | human}}, {{cast.size_byte}} Bytes</p>
            <div class="asc-player">
                <div id="player-{{cast.id}}">Loading...</div>
                <div class="pico marks-box" id="markers-{{cast.id}}"></div>
            </div>
            {% endfor %}
        </main>

        <script type="module">
            import { PtyPlayer } from "/replay/static/js/app.js";

            const speedSlider = document.getElementById("speed");
            const idleSlider = document.getElementById("idle");

            function currentIdleLimit() {
                const v = Number(idleSlider.value);
                return v === 62 ? null : v;
            }

            const players = new Map();

            const endpoint = {{endpoint | json | safe}};
            const casts = {{casts | json | safe}};

            function secondToTime(seconds) {
                return new Date(seconds * 1000).toISOString().substr(11, 8);
            }

            function renderRow(m) {
                return `
                <tr data-mark-id="${m.id}" data-second="${m.second}">
                    <td><span>${secondToTime(m.second)}</span></td>
                    <td><span>${m.note}</span></td>
                    <td><button type="button" class="del-btn contrast outline">✖</button></td>
                </tr>`;
            }

            function renderMarkersTable(container, cast) {
                const rows = cast.marks
                    .map(m => renderRow(m))
                    .join('');

                container.innerHTML = `<table class="marks" data-cast-id=${cast.id}>
                <thead>
                    <tr><th>time</th><th>marker</th><th></th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span>${secondToTime(0)}</span></td>
                        <td><input style="margin-bottom: 0;" name="note" placeholder="note..."></td>
                        <td><button type="button" class="add-btn outline">➕</button></td>
                    </tr>
                    ${rows}
                </tbody>
                </table>`;
            }

            function initPlayers() {
                casts.forEach((cast) => {
                    const container = document.getElementById(`player-${cast.id}`);
                    container.innerHTML = "";
                    const player = new PtyPlayer(
                        `${endpoint}/${cast.path}`,
                        document.getElementById(`player-${cast.id}`),
                        {
                            rows: cast.height,
                            cols: cast.width,
                            speed: 1,
                            idleTime: null,
                            markers: cast.marks,
                            controls: true,
                        }
                    )
                    const box = document.getElementById(`markers-${cast.id}`);
                    if (box) renderMarkersTable(box, cast);

                    const timeSpan = box.querySelector('tbody tr:first-child span');
                    setInterval(() => {
                        timeSpan.textContent = secondToTime(player.getCurrentTime());
                    }, 100);
                    players.set(cast.id, player);
                });
            }

            speedSlider.addEventListener('input', async() => {
                speedVal.value = speedSlider.value;
                const speed = Number(speedSlider.value);
                const tasks = [...players.values()].map(player=> player.setSpeed(speed));
                await Promise.all(tasks);
            });

            const markerBoxes = document.querySelectorAll('.marks-box');
            idleSlider.addEventListener("input", async() => {
                idleVal.value = idleSlider.value == 62 ? "inf" : idleSlider.value;
                const idle = idleSlider.value == 62 ? null : Number(idleSlider.value);
                const tasks = [...players.values()].map(player => player.setIdleTimeLimit(idle));
                await Promise.all(tasks);
                markerBoxes.forEach(box => {
                    box.style.display = idle != null ? 'none': '';
                });
            });

            initPlayers();

            async function requestJSON(url, method, body){
                const r = await fetch(url, {
                    method: method,
                    headers: { 'Content-Type':'application/json' },
                    body: JSON.stringify(body)
                });
                if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
                return r.json();
            }

            document.addEventListener("click", async e => {
                if (e.target.matches('.add-btn, .del-btn')) {
                    e.preventDefault();
                }
                if (e.target.matches(".add-btn")) {
                    const tbl = e.target.closest("table");
                    const castId = +tbl.dataset.castId;
                    const noteInput = tbl.querySelector("input[name=note]");
                    const note = noteInput.value.trim();
                    if (!note) return;

                    const sec = players.get(castId).getCurrentTime();

                    const resp = await requestJSON(
                        `/replay/mark`,
                        "POST",
                        { cast_id: castId, second: sec, note }
                    );
                    if (!resp.ok) {
                        return alert("Failed to add mark");
                    }
                    const mark = { id: resp.mark_id, second: sec, note };

                    const player = players.get(castId);
                    player.addMarker(sec, note);

                    const tbody = tbl.tBodies[0];
                    const newRowHtml = renderRow(mark);
                    let inserted = false;

                    for (const row of tbody.querySelectorAll('tr[data-mark-id]')) {
                        const rowSec = Number(row.dataset.second);
                        if (rowSec > mark.second) {
                            row.insertAdjacentHTML('beforebegin', newRowHtml);
                            inserted = true;
                            break;
                        }
                    }
                    if (!inserted) {
                        tbody.insertAdjacentHTML('beforeend', newRowHtml);
                    }
                    noteInput.value = '';
                }
                else if (e.target.matches(".del-btn")) {
                    const row = e.target.closest("tr");
                    const markId = +row.dataset.markId;
                    const castId = +row.closest("table").dataset.castId;
                    const ok = (await requestJSON('/replay/mark', "DELETE", { mark_id: markId })).ok;
                    if (!ok) return alert("Failed to delete mark");
                    players.get(castId).deleteMarker(markId);
                    row.remove();
                }
            })
        </script>
    </body>
</html>
